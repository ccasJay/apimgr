package sync

import (
	"fmt"
	"sort"
	"strings"

	"apimgr/config/models"
)

// GenerateEnvScript generates environment variable script content
func GenerateEnvScript(cfg *models.APIConfig) string {
	var buf strings.Builder

	// Add comments
	buf.WriteString("# Auto-generated active configuration - updated on each config change\n")
	buf.WriteString("# Do not edit this file manually\n\n")

	// Clear old environment variables
	buf.WriteString("# Clear previously set environment variables\n")
	buf.WriteString("unset ANTHROPIC_API_KEY\n")
	buf.WriteString("unset ANTHROPIC_AUTH_TOKEN\n")
	buf.WriteString("unset ANTHROPIC_BASE_URL\n")
	buf.WriteString("unset ANTHROPIC_MODEL\n")
	buf.WriteString("unset APIMGR_ACTIVE\n\n")

	// Set new environment variables
	buf.WriteString("# Set new environment variables\n")
	if cfg.APIKey != "" {
		buf.WriteString(fmt.Sprintf("export ANTHROPIC_API_KEY=%q\n", cfg.APIKey))
	}
	if cfg.AuthToken != "" {
		buf.WriteString(fmt.Sprintf("export ANTHROPIC_AUTH_TOKEN=%q\n", cfg.AuthToken))
	}
	if cfg.BaseURL != "" {
		buf.WriteString(fmt.Sprintf("export ANTHROPIC_BASE_URL=%q\n", cfg.BaseURL))
	}
	if cfg.Model != "" {
		buf.WriteString(fmt.Sprintf("export ANTHROPIC_MODEL=%q\n", cfg.Model))
	}
	buf.WriteString(fmt.Sprintf("export APIMGR_ACTIVE=%q\n", cfg.Alias))

	return buf.String()
}

// showEnvChanges displays the changes between old and new env maps
func showEnvChanges(oldEnv, newEnv map[string]interface{}) {
	// Create a map of all variables
	allVars := make(map[string]bool)
	for k := range oldEnv {
		allVars[k] = true
	}
	for k := range newEnv {
		allVars[k] = true
	}

	// Create sorted list of variables
	var sortedVars []string
	for k := range allVars {
		sortedVars = append(sortedVars, k)
	}
	sort.Strings(sortedVars)

	// Print table header
	fmt.Printf("┌──────────────────────────────┬─────────────────┬─────────────────┐\n")
	fmt.Printf("│ Variable                     │ Old Value       │ New Value       │\n")
	fmt.Printf("├──────────────────────────────┼─────────────────┼─────────────────┤\n")

	// Calculate summary counts
	updatedCount, addedCount, deletedCount, preservedCount := 0, 0, 0, 0

	// Print table rows
	for _, varName := range sortedVars {
		oldVal, oldExists := oldEnv[varName]
		newVal, newExists := newEnv[varName]

		// Determine the type of change
		var status string
		if !oldExists {
			status = "added"
			addedCount++
		} else if !newExists {
			status = "deleted"
			deletedCount++
		} else if fmt.Sprintf("%v", oldVal) != fmt.Sprintf("%v", newVal) {
			status = "updated"
			updatedCount++
		} else {
			status = "preserved"
			preservedCount++
		}

		// Format values for display
		oldValStr := fmt.Sprintf("%v", oldVal)
		if !oldExists {
			oldValStr = "(not set)"
		}
		newValStr := fmt.Sprintf("%v", newVal)
		if !newExists {
			newValStr = "(deleted)"
		}
		if status == "preserved" {
			newValStr = "(unchanged)"
		}

		// Truncate long strings for table display
		const maxLen = 20
		if len(oldValStr) > maxLen {
			oldValStr = oldValStr[:maxLen-3] + "..."
		}
		if len(newValStr) > maxLen {
			newValStr = newValStr[:maxLen-3] + "..."
		}

		// Print the table row
		fmt.Printf("│ %-38s │ %-20s │ %-20s │\n", varName, oldValStr, newValStr)
	}

	// Print table footer and summary
	fmt.Printf("└──────────────────────────────┴─────────────────┴─────────────────┘\n\n")
	fmt.Printf("Summary:\n")
	fmt.Printf("• %d variable(s) will be updated\n", updatedCount)
	fmt.Printf("• %d variable(s) will be added\n", addedCount)
	fmt.Printf("• %d variable(s) will be deleted\n", deletedCount)
	fmt.Printf("• %d variable(s) will be preserved\n", preservedCount)
}

// generateDiffReport generates a human-readable report showing differences between old and new content
func generateDiffReport(originalContent, updatedContent string) (string, error) {
	// Extract env fields from both
	originalEnv, err := extractEnv(originalContent)
	if err != nil {
		return "", err
	}

	updatedEnv, err := extractEnv(updatedContent)
	if err != nil {
		return "", err
	}

	// Create a report buffer
	var report strings.Builder

	// Set up table headers
	report.WriteString("┌──────────────────────────────┬─────────────────┐\n")
	report.WriteString("│ Variable                     │ New Value       │\n")
	report.WriteString("├──────────────────────────────┼─────────────────┤\n")

	// Create a map of all variables
	allVars := make(map[string]bool)
	for k := range originalEnv {
		allVars[k] = true
	}
	for k := range updatedEnv {
		allVars[k] = true
	}

	// Create sorted list of variables
	var sortedVars []string
	for k := range allVars {
		sortedVars = append(sortedVars, k)
	}
	sort.Strings(sortedVars)

	// Generate table rows
	for _, varName := range sortedVars {
		newVal, newExists := updatedEnv[varName]

		// Format values for display
		newValStr := fmt.Sprintf("%v", newVal)
		if !newExists {
			newValStr = "(deleted)"
		}

		// Truncate long strings for table display
		const maxLen = 20
		if len(newValStr) > maxLen {
			newValStr = newValStr[:maxLen-3] + "..."
		}

		// Write the table row
		report.WriteString(fmt.Sprintf("│ %-38s │ %-20s │\n", varName, newValStr))
	}

	// Close table
	report.WriteString("└──────────────────────────────┴─────────────────┘\n")

	return report.String(), nil
}
